			FUNCTION HASHING

This patch was developed for Igor (129.16.50.30 1701) and was tested with
Igor's game driver (a 3.1.2 variant) and with Igor's mudlib.
It was ported to 3.1.2, and tested with the 2.4.5 mudlib available from 
alcazar.cd.chalmers.se. It has only been tested in compat-mode. 
It will compile in native mode, but I had no mudlib to test it on.

PART 1: Concept
  There are two basic ways to add a standard item to the game: Either write
a file that inherits a standard object and configures it in its creation 
function, or clone a standard object and call functions in it to configure it.
  Inheriting is much more expensive than cloning and configuring, and for some
time I have been looking for ways to close that gap, because I prefer the
former.
  The greatest expense is that of copying all function data to inheriting 
objects. It is possible to avoid this by searching through inherited programs
as well as the current program when looking for a function. However, this means
that local calls can no longer be hard-coded, because function_index_offset
cannot be used. Searching through the function lists for every local call
would be very slow.
  Luckily, once function_index_offset is no longer used, there is more freedom
in assigning function indices. In other words, the function list can become
a hash table, which will speed up searching for functions a great deal.
  This means that apply() will become much faster, and searching for a function
is not much more slower than calling it directly, making the project feasible.
  The base of the patch is the function search_for_function. Most of the other
changes involve rewriting functions to use search_for_function instead of a 
linear search through the function structs.
  The function names are hashed by pointer, not by string. search_for_function
expects its 'name' argument to point into the shared string table.  
    

PART 2: Compatibility effects of function-hashing
 - It pretends to support 'private inherit' but doesn't, really.
   Full support was not necessary for the Igor mudlib, and would have
   slowed down function calling.
 - simul_efun handling has changed slightly. Whether a call is an sfun
   call is now determined run-time, so it is possible to mask sfuns.
 - It is no longer possible to inherit 'pure' prototypes. When parsing is 
   finished, all prototypes that have not been replaced by a definition are
   discarded. I did this because it saves memory while making multiple
   inheritance cleaner.
 - The behaviour in case of function name conflicts (with multiple inheritance)
   has been changed. If an object C inherits A and B (in that order), B can
   mask local function calls in A. An unfortunate side-effect is that private
   or static functions in B will mask public functions in A.
 - The simul_efun file should be checked carefully, because calls to it
   will now have their number of arguments and return types checked.
 - I am not sure if it should be possible to refer to an indirectly 
   inherited program by name. In any case the patch does not allow it.
 - Functions called with :: now have to be defined when the call is parsed.
   This means that some 'inherit' statements may have to be moved toward the
   top of the program.
 - In Igor there was one case where the old code did not properly enforce 
   'private' functions. The patch corrected this.
 - There was a bug in function_call (postlang.y): in some cases funp->type was 
   returned instead of (funp->type & TYPE_MOD_MASK). This has been corrected.

PART 3: Memory effects of function-hashing
 - Only the functions defined by a program will be listed in that program.
   This saves about 16 bytes per inherited function.
   In the Igor mudlib, that is about 3K per monster file and 800 bytes
   per room.
 - All inherited programs will now have an entry in a program,
   not just the ones inherited directly.
   This costs 8 bytes per indirectly inherited program.
 - Local function names will sometimes appear in the 'strings' array.
   This costs about 4 bytes per function called locally.
 - General effects: I estimate a savings of about 25%-30% on program block
   size, and a 10% reduction of overall memory size. In Igor, there was a 50%
   decrease of program block size, and a 20% reduction of overall memory size.

PART 4: Speed effects of function-hashing
 - apply() is now far, far faster. I estimate at least a tenfold speed
   increase.
 - parsing is probably faster, because all the defined() calls will search
   through inherited programs at the new speed. However, hashing the 
   function tables takes more time than just copying them.
 - :: calls (to inherited functions) are just a bit faster (because
   setup_new_frame() is faster)
 - local calls are slower, probably about five or tenfold.
 - General effects: There are about as many external calls as local calls.
   Because external calls have been speeded up more than local calls have been
   slowed down, I expect an overall speed increase. I have not been
   able to measure it.

PART 5: Changes to the source
 - Functions are no longer copied to inheriting programs.
 - the 'inherit' list will also contain indirectly inherited programs. 
   This is so that :: calls can be passed an index into the 'inherit' list.
 - search_for_function() is used to look for functions. It will also compensate
   for typed (i.e. 'static', 'nomask') inherits.
 - All strings that are to be passed to search_for_function should be shared.
 - F_CALL_BY_ADDRESS has been removed. There are two new opcodes:
     F_CALL_SELF for local calls, and
     F_CALL_DOWN for :: calls.
 - setup_new_frame does less work than it used to do.
 - simul_efuns are now local calls, not call_others. When F_CALL_SELF cannot
   find a function in the current object, it will apply it to the simul_efun
   object. The parser will check simul_efun calls for type and number of 
   arguments.
 - The apply() cache has been removed. Searching for a function is only a bit
   more costly than accessing a cache. 
 - the heart_beat handling now uses 2 indices: one into the inherit list, 
   and one into the function list where it is defined.
 Patched files:
 - array.c: inherit_list() has been changed to use the new 'inherit' list.
 - backend.c: heart_beat handling changed
 - exec.h: NAME_UNDEFINED and NAME_INHERITED have been removed. NAME_PROTOTYPE
      has been restricted to use within the parser, and NAME_HIDDEN is only
      used by variables.
 - interpret.h: function_index_offset has been removed from the control stack
 - lex.c: The new opcodes have been added to the traceback code
 - lint.h: Prototype for call_function() has been changed
 - simul_efun.c: Simplified. Now it only loads the simul_efun object and 
   remembers its name. 
 - interpret.c, postlang.y, prelang.y: Most of the changes are in these files.

PART 6: Future plans:
 - Test several hash functions for performance
 - Variable names are copied, giving some of the same quirks as the 
   function calls used to have. They could easily get a similar patch, which
   will save even more memory.
 - The list of inherited programs makes it easy to check for duplicate
   inheritance of the same program. Perhaps the parser could generate warnings
   about that.

                                          Dark

P.S. Many thanks to Zellski for saying 'hashing' at exactly the right time :)
     Thanks to Dworkin for helping me to decide whether to hash or to sort.
     More thanks to Zellski for helping me with some design decisions.
     Thanks to Abigail for writing very complicated objects that depend on lots
     of obscure GD features, which provided me with a nice test set...
	
You can contact me by mailing to 'dark' at Igormud (129.16.50.30 1701) or
by email at richard@cs.rug.nl.
