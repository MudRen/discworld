/*
	efunctions.c: this file contains the efunctions called from
	inside eval_instruction() in interpret.c.  Note: if you are adding
    local efunctions that are specific to your driver, you would be better
    off adding them to a separate source file.  Doing so will make it much
    easier for you to upgrade (won't have to patch this file).
*/

#include "efuns.h"

int using_bsd_malloc = 0;
int using_smalloc = 0;

void
f_add_action(num_arg, instruction)
int num_arg, instruction;
{
  struct svalue *arg;
  arg = sp - num_arg + 1;
  if (num_arg == 3)
    {	if (arg[2].type != T_NUMBER)
	  bad_arg(3, instruction);
	}
  add_action(arg[0].u.string,
	     num_arg > 1 ? arg[1].u.string : 0,
	     num_arg > 2 ? arg[2].u.number : 0);
  pop_n_elems(num_arg-1);
}

/*
  OBSOLETE
	I'm not sure this function should exist anymore, outside of
	being a simul_efun that tells you to use add_action...
	--Sulam
*/
#ifdef F_ADD_VERB
void
f_add_verb(num_arg, instruction)
int num_arg, instruction;
{
  add_verb(sp->u.string, 0);
  return;
}
#endif

void
f_add_worth(num_arg, instruction)
int num_arg, instruction;
{
  struct object *ob;
  int worth;

  assert_master_ob_loaded("add_worth");
  if (current_object->uid != backbone_uid
      && current_object->uid != master_ob->uid)
    error("Illegal call of add_worth.\n");
  if (num_arg == 2)
    {
      ob = sp->u.ob;
      worth = (sp-1)->u.number;
      pop_stack();
    }
  else
    {
      if (!previous_ob)
	return;
      ob = previous_ob;
      worth = sp->u.number;
    }
  add_worth (&ob->stats, worth);
}

/*
  OBSOLETE
	If we get rid of add_verb, we should also get rid of this...
	--Sulam
*/
#ifdef F_ADD_XVERB
void
f_add_xverb(num_arg, instruction)
int num_arg, instruction;
{
  add_verb(sp->u.string, 1);
}
#endif

void
f_all_inventory(num_arg, instruction)
int num_arg, instruction;
{
  struct vector *vec;

  vec = all_inventory(sp->u.ob);
  pop_stack();
  if (!vec)
    {
      push_number(0);
      return;
    }
  push_vector(vec);		/* This will make ref count == 2 */
  vec->ref--;
}

void
f_allocate(num_arg, instruction)
int num_arg, instruction;
{
  struct vector *vec;

  vec = allocate_array(sp->u.number);
  pop_stack();
  push_vector(vec);
  vec->ref--;
}

void
f_allocate_mapping(num_arg, instruction)
int num_arg, instruction;
{
  struct mapping *map;

  map = allocate_mapping(sp->u.number);
  pop_stack();
  push_mapping(map);
  map->ref--;
}

void
f_break_point(num_arg, instruction)
int num_arg, instruction;
{
  break_point(); /* generated by lang.y when -d. Will check stack. */
  return;
}

#ifdef F_CACHE_STATS

void print_cache_stats ()
{
   add_message ("Function cache information\n");
   add_message ("-------------------------------\n");
   add_message("%% cache hits:    %10.2f\n",
	       100 * ((double)apply_low_cache_hits / apply_low_call_others));
   add_message("call_others:     %10lu\n", apply_low_call_others);
   add_message("cache hits:      %10lu\n", apply_low_cache_hits);
   add_message("cache size:      %10lu\n", APPLY_CACHE_SIZE);
   add_message("slots used:      %10lu\n", apply_low_slots_used);
   add_message("%% slots used:    %10.2f\n",
	       100 * ((double)apply_low_slots_used / APPLY_CACHE_SIZE));
   add_message("collisions:      %10lu\n", apply_low_collisions);
   add_message("%% collisions:    %10.2f\n",
	       100 * ((double)apply_low_collisions / apply_low_call_others));
}

void f_cache_stats(num_arg, instruction)
int num_arg, instruction;
{
   print_cache_stats();
   push_number(0);
}
#endif

void
f_call_other(num_arg, instruction)
int num_arg, instruction;
{
  struct svalue *arg, tmp;

  if (current_object->flags & O_DESTRUCTED)
    {				/* No external calls allowed */
      pop_n_elems(num_arg);
      push_undefined();
      return;
    }
  arg = sp - num_arg + 1;
  if (arg[1].u.string[0] == ':')
    error("Illegal function name in call_other: %s\n",
	  arg[1].u.string);
  if (arg[0].type == T_OBJECT)
    ob = arg[0].u.ob;
  else if (arg[0].type == T_POINTER)
    {
      extern int call_all_other PROT((struct vector *, char *, int));
      
      (void) call_all_other(arg[0].u.vec, arg[1].u.string, num_arg-2);
      pop_n_elems(2);
      push_number(0);
      return;
    }
  else
    {
      ob = find_object(arg[0].u.string);
     if (!ob || !object_visible(ob))
	error("call_other() couldn't find object\n");
    }
  /*
    Send the remaining arguments to the function.
    */
  if (TRACEP(TRACE_CALL_OTHER))
    {
      do_trace("Call other ", arg[1].u.string, "\n");
    }
  if (apply_low(arg[1].u.string, ob, num_arg-2) == 0)
    {				/* Function not found */
      pop_n_elems(2);
      push_undefined();
      return;
    }
  /*
    The result of the function call is on the stack.  So is the
    function name and object that was called, though.
    These have to be removed.
    */
  tmp = *sp--;			/* Copy the function call result */
  pop_n_elems(2);		/* Remove old arguments to call_other */
  *++sp = tmp;			/* Re-insert function result */
  return;
}

void
f_call_out(num_arg, instruction)
int num_arg, instruction;
{
  struct svalue *arg;

  arg = sp - num_arg + 1;
  if (!(current_object->flags & O_DESTRUCTED))
    new_call_out(current_object, arg[0].u.string, arg[1].u.number,
		 num_arg - 3, (num_arg >= 3) ? &arg[2] : 0);
  pop_n_elems(num_arg);
  push_number(0);
}

void
f_call_out_info(num_arg, instruction)
int num_arg, instruction;
{
  push_vector(get_all_call_outs());
  sp->u.vec->ref--;		/* set ref count to 1 */
}

void
f_capitalize(num_arg, instruction)
int num_arg, instruction;
{
  if (islower(sp->u.string[0]))
    {
      char *str;
		
      str = string_copy(sp->u.string);
      str[0] += 'A' - 'a';
      pop_stack();
      push_malloced_string(str);
    }
  return;
}

void
f_cat(num_arg, instruction)
int num_arg, instruction;
{
  struct svalue *arg;
  int start = 0, len = 0;

  arg = sp - num_arg + 1;
  if (num_arg > 1)
    start = arg[1].u.number;
  if (num_arg == 3)
    {	
      if (arg[2].type != T_NUMBER)
	bad_arg(2, instruction);
      len = arg[2].u.number;
    }
  i = print_file(arg[0].u.string, start, len);
  pop_n_elems(num_arg);
  push_number(i);
}

void
f_children(num_arg, instruction)
int num_arg, instruction;
{
  struct vector *vec;

  vec = children(sp->u.string);
  pop_stack();
  if (!vec)
    push_number(0);
  else
    {
      push_vector(vec);
      vec->ref--;		/* reset ref count */
    }
}

void
f_clear_bit(num_arg, instruction)
int num_arg, instruction;
{
  char *str;
  int len, ind;

  if (sp->u.number > MAX_BITS)
    error("clear_bit: %d > MAX_BITS\n", sp->u.number);
  len = strlen((sp-1)->u.string);
  ind = sp->u.number / 6;
  if (ind >= len)
    {				/* return first arg unmodified */
      pop_stack();
      return;
    }
  str = XALLOC(len+1);
  memcpy(str, (sp-1)->u.string, len+1);	/* including null byte */
  if (str[ind] > 0x3f + ' ' || str[ind] < ' ')
    error("Illegal bit pattern in clear_bit character %d\n", ind);
  str[ind] = ((str[ind] - ' ') & ~(1 << (sp->u.number % 6))) + ' ';
  pop_n_elems(2);
  push_malloced_string(str);
}

/*
  OBSOLETE
  clone_object should be made into a simul_efun and then go away over time
*/

void
f_clone_object(num_arg, instruction)
int num_arg, instruction;
{
	f_new(num_arg, instruction);
}

void
f_clonep(num_arg, instruction)
int num_arg, instruction;
{
  if ((sp->type == T_OBJECT) && (sp->u.ob->flags & O_CLONE))
    assign_svalue(sp, &const1);
  else
    assign_svalue(sp, &const0);
}

void
f_command(num_arg, instruction)
int num_arg, instruction;
{
  i = command_for_object(sp->u.string, 0);
  pop_stack();
  push_number(i);
}

#ifdef F_COMMANDS
void
f_commands(num_arg, instruction)
int num_arg, instruction;
{
  struct vector *vec;

  vec = commands(current_object);
  push_vector(vec);
  vec->ref--;			/* reset ref count to 1 */
}
#endif /* F_COMMANDS */

/*
  OBSOLETE
	Couldn't this be a simul_efun??  Do we even need it as a
	function at all??
	--Sulam

   problem with making it a simul_efun is that we are limited to copying
   files of size less than read_file is limited to
*/

void
f_cp(num_arg, instruction)
int num_arg, instruction;
{
  i = copy_file(sp[-1].u.string, sp[0].u.string);
  pop_n_elems(2);
  push_number(i);
}

#ifdef F_CREATOR
void
f_creator(num_arg, instruction)
int num_arg, instruction;
{
  ob = sp->u.ob;
  if (ob->uid == 0) {
    assign_svalue(sp, &const0);
  } else {
    pop_stack();
    push_string(ob->uid->name, STRING_CONSTANT);
  }
}
#endif /* CREATOR */

void
f_crypt(num_arg, instruction)
int num_arg, instruction;
{
  char *res, salt[2];
  char *choice =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ./";
	
  if (sp->type == T_STRING && strlen(sp->u.string) >= 2)
    {
      salt[0] = sp->u.string[0];
      salt[1] = sp->u.string[1];
    }
  else
    {
      salt[0] = choice[random_number(strlen(choice))];
      salt[1] = choice[random_number(strlen(choice))];
    }
#ifdef sun
  res = string_copy(_crypt((sp-1)->u.string, salt));
#else
  res = string_copy(crypt((sp-1)->u.string, salt));
#endif
  pop_n_elems(2);
  push_malloced_string(res);
}

void
f_ctime(num_arg, instruction)
int num_arg, instruction;
{
  char *cp;

  cp = string_copy(time_string(sp->u.number));
  pop_stack();
  push_malloced_string(cp);
  /* Now strip the newline. */
  cp = strchr(cp, '\n');
  if (cp)
    *cp = '\0';
}

void
f_debug_info(num_arg, instruction)
int num_arg, instruction;
{
  struct svalue *arg, res;

  arg = sp - num_arg + 1;
  switch (arg[0].u.number)
    {
    case 0:
      {
	int flags;
	struct object *obj2;

	if (num_arg != 2)
	  error("bad number of args to debug_info\n");
	if (arg[1].type != T_OBJECT)
	  bad_arg(1, instruction);
	ob = arg[1].u.ob;
	flags = ob->flags;
	add_message("O_HEART_BEAT      : %s\n",
		    flags & O_HEART_BEAT      ?"TRUE":"FALSE");
	add_message("O_IS_WIZARD       : %s\n",
		    flags & O_IS_WIZARD       ?"TRUE":"FALSE");
	add_message("O_ENABLE_COMMANDS : %s\n",
		    flags & O_ENABLE_COMMANDS ?"TRUE":"FALSE");
	add_message("O_CLONE           : %s\n",
		    flags & O_CLONE           ?"TRUE":"FALSE");
	add_message("O_DESTRUCTED      : %s\n",
		    flags & O_DESTRUCTED      ?"TRUE":"FALSE");
	add_message("O_SWAPPED         : %s\n",
		    flags & O_SWAPPED          ?"TRUE":"FALSE");
	add_message("O_ONCE_INTERACTIVE: %s\n",
		    flags & O_ONCE_INTERACTIVE?"TRUE":"FALSE");
	add_message("O_RESET_STATE     : %s\n",
		    flags & O_RESET_STATE     ?"TRUE":"FALSE");
	add_message("O_WILL_CLEAN_UP   : %s\n",
		    flags & O_WILL_CLEAN_UP   ?"TRUE":"FALSE");
	add_message("O_WILL_RESET: %s\n",
		    flags & O_WILL_RESET ?"TRUE":"FALSE");
	add_message("total light : %d\n", ob->total_light);
	add_message("next_reset  : %d\n", ob->next_reset);
	add_message("time_of_ref : %d\n", ob->time_of_ref);
	add_message("ref         : %d\n", ob->ref);
#ifdef DEBUG
	add_message("extra_ref   : %d\n", ob->extra_ref);
#endif
	add_message("swap_num    : %ld\n", ob->swap_num);
	add_message("name        : '%s'\n", ob->name);
	add_message("next_all    : OBJ(%s)\n",
		    ob->next_all ? ob->next_all->name : "NULL");
	if (obj_list == ob)
	  add_message("This object is the head of the object list.\n");
	for (obj2 = obj_list, i=1; obj2; obj2 = obj2->next_all, i++)
	  if (obj2->next_all == ob)
	    {
	      add_message("Previous object in object list: OBJ(%s)\n",
			  obj2->name);
	      add_message("position in object list:%d\n",i);
	    }
	assign_svalue_no_free(&res,&const0);
	break;
      }
    case 1:
      if (num_arg != 2)
	error("bad number of arguments to debug_info");
      if ( arg[1].type != T_OBJECT)
	bad_arg(1,instruction);
      ob = arg[1].u.ob;
      add_message("program ref's %d\n", ob->prog->p.i.ref);
      add_message("Name %s\n", ob->prog->name);
      add_message("program size %d\n",
		  ob->prog->p.i.program_size);
      add_message("num func's %d (%d) \n", ob->prog->p.i.num_functions,
		  ob->prog->p.i.num_functions * sizeof(struct function));
      add_message("num strings %d\n", ob->prog->p.i.num_strings);
      add_message("num vars %d (%d)\n", ob->prog->p.i.num_variables,
		  ob->prog->p.i.num_variables * sizeof(struct variable));
      add_message("num inherits %d (%d)\n", ob->prog->p.i.num_inherited,
		  ob->prog->p.i.num_inherited * sizeof(struct inherit));
      add_message("total size %d\n", ob->prog->p.i.total_size);
      assign_svalue_no_free(&res,&const0);
      break;
    default:
      bad_arg(1,instruction);
    }
  pop_n_elems(num_arg);
  sp++;
  *sp = res;
}

#if (defined(DEBUGMALLOC) && defined(DEBUGMALLOC_EXTENSIONS))
void
f_debugmalloc(num_arg, instruction)
int num_arg, instruction;
{
	dump_debugmalloc((sp - 1)->u.string, sp->u.number);
	pop_n_elems(2);
	push_number(0);
}

void
f_set_malloc_mask(num_arg, instruction)
int num_arg, instruction;
{
	set_malloc_mask(sp->u.number);
	pop_stack();
	push_number(0);
}
#endif /* (defined(DEBUGMALLOC) && defined(DEBUGMALLOC_EXTENSIONS)) */

void
f_deep_inherit_list(num_arg, instruction)
int num_arg, instruction;
{
  struct vector *vec;
  extern struct vector *deep_inherit_list PROT((struct object *));

  vec = deep_inherit_list(sp->u.ob);
  pop_stack();
  push_vector(vec);
  vec->ref--;			/* reset ref count */
}

#ifdef DEBUG_MACRO

void
f_set_debug_level(num_arg, instruction)
int num_arg, instruction;
{
	debug_level = sp->u.number;
	pop_stack();
	push_number(0);
}

#endif

void
f_deep_inventory(num_arg, instruction)
int num_arg, instruction;
{
  struct vector *vec;

  vec = deep_inventory(sp->u.ob, 0);
  pop_stack();
  push_vector(vec);
  vec->ref--;			/* reset ref count */
}

void
f_destruct(num_arg, instruction)
int num_arg, instruction;
{
	struct object *ob;

#ifdef DISCWORLD
	if(sp->type == T_OBJECT && (current_object->interactive ||
           sp->u.ob == current_object)) {
#else
	if(sp->type == T_OBJECT) {
#endif
		ob = sp->u.ob;
	} else {
		error("Invalid argument to destruct()\n");
	}
	destruct_object(sp);
	pop_stack();
	push_number(1);
}

void
f_disable_commands(num_arg, instruction)
int num_arg, instruction;
{
  enable_commands(0);
  push_number(0);
}

void
f_dumpallobj(num_arg, instruction)
int num_arg, instruction;
{
	char *fn = "/OBJ_DUMP";

	if (num_arg == 1) {
		fn = sp->u.string;
	}
	dumpstat(fn);
	if (num_arg == 1) {
		pop_stack();
	}
	push_number(0);
}

#ifdef EACH
/* f_each */

void
f_each(num_arg, instruction)
int num_arg, instruction;
{
	struct mapping *m;

	m = sp->u.map;
	pop_stack();
	push_vector(mapping_each(m));
}
#endif

#ifdef ED
void
f_ed(num_arg, instruction)
int num_arg, instruction;
{
	if (num_arg == 0) {
		if (command_giver == 0 || command_giver->interactive == 0)
			push_number(0);
		else {
			ed_start(0, 0, 0, 0);
			push_number(1);
		}
	} else if (num_arg == 1)
		ed_start(sp->u.string, 0, 0, 0);
	else if (num_arg == 2) {
		if (sp->type == T_STRING)
			ed_start((sp-1)->u.string, sp->u.string, 0, current_object);
		else
			ed_start((sp-1)->u.string, 0, 0, 0);
		pop_stack();
	} else { /* num_arg == 3 */
		if (((sp-1)->type == T_STRING) && (sp->type == T_NUMBER)) {
			ed_start((sp-2)->u.string, (sp-1)->u.string, sp->u.number,
				current_object);
		} else {
			ed_start((sp-1)->u.string, 0, 0, 0);
		}
		pop_n_elems(2);
	}
}
#endif

void
f_enable_commands(num_arg, instruction)
int num_arg, instruction;
{
  enable_commands(1);
  push_number(1);
}


void
f_enable_wizard(num_arg, instruction)
int num_arg, instruction;
{
  if (current_object->interactive)
    {
      current_object->flags |= O_IS_WIZARD;
      push_number(1);
    }
  else
    push_number(0);
}

void
f_environment(num_arg, instruction)
int num_arg, instruction;
{
  if (num_arg)
    {
      ob = environment(sp);
      pop_stack();
    }
  else if (!(current_object->flags & O_DESTRUCTED))
    ob = current_object->super;
  else
    ob = 0;
  if (ob)
    push_object(ob);
  else
    push_number(0);
}

void
f_exec(num_arg, instruction)
int num_arg, instruction;
{
  i = replace_interactive((sp-1)->u.ob, sp->u.ob);
  pop_stack();
  pop_stack();
  push_number(i);
}

void
f_explode(num_arg, instruction)
int num_arg, instruction;
{
  struct vector *vec;
	
  vec = explode_string((sp-1)->u.string, sp->u.string);
  pop_n_elems(2);
  if (vec)
    {
      push_vector(vec);		/* This will make ref count == 2 */
      vec->ref--;
    }
  else
    push_number(0);
}

void
f_export_uid(num_arg, instruction)
int num_arg, instruction;
{
  if (current_object->euid == NULL)
    error("Illegal to export uid 0\n");
  ob = sp->u.ob;
  pop_stack();
  if (ob->euid)
    push_number(0);
  else
    {
      ob->uid = current_object->euid;
      push_number(1);
    }
}

/*
  OBSOLETE
	Isn't this a simul_efun??  Why do we have it here??
	--Sulam
*/

void
f_extract(num_arg, instruction)
int num_arg, instruction;
{
  int len, from, to;
  struct svalue *arg;
  char *res;

  arg = sp - num_arg + 1;
  len = strlen(arg[0].u.string);
  if (num_arg == 1)
    return;
  from = arg[1].u.number;
  if (from < 0)
    from = len + from;
  if (from >= len)
    {
      pop_n_elems(num_arg);
      push_string("", STRING_CONSTANT);
      return;
    }
  if (num_arg == 2)
    {
      res = string_copy(arg->u.string + from);
      pop_n_elems(2);
      push_malloced_string(res);
      return;
    }
  if (arg[2].type != T_NUMBER)
    error("Bad third argument to extract\n");
  to = arg[2].u.number;
  if (to < 0)
    to = len + to;
  if (to < from)
    {
      pop_n_elems(3);
      push_string("", STRING_CONSTANT);
      return;
    }
  if (to >= len)
    to = len - 1;
  if (to == len -1)
    {
      res = string_copy(arg->u.string + from);
      pop_n_elems(3);
      push_malloced_string(res);
      return;
    }
  res = XALLOC(to - from + 2);
  strncpy(res, arg[0].u.string + from, to - from + 1);
  res[to - from + 1] = '\0';
  pop_n_elems(3);
  push_malloced_string(res);
}

void
f_file_name(num_arg, instruction)
int num_arg, instruction;
{
  char *name, *res;

  /* This function now returns a leading '/' */
  name = sp->u.ob->name;
  res = (char *)add_slash(name);
  pop_stack();
  push_malloced_string(res);
}

void
f_file_size(num_arg, instruction)
int num_arg, instruction;
{
  i = file_size(sp->u.string);
  pop_stack();
  push_number(i);
}

void
f_filter_array(num_arg, instruction)
int num_arg, instruction;
{
  struct vector *vec;
  struct svalue *arg;

  arg = sp - num_arg + 1; ob = 0;
  if (arg[2].type == T_OBJECT)
    ob = arg[2].u.ob;
  else if (arg[2].type == T_STRING)
   {
     ob = find_object(arg[2].u.string);
     if (ob && !object_visible(ob)) ob = 0;
   }
  if (!ob)
    error("Bad third argument to filter_array()\n");
  if (arg[0].type == T_POINTER)
    {
      check_for_destr(arg[0].u.vec);
      vec = filter(arg[0].u.vec, arg[1].u.string, ob,
		   num_arg > 3 ? sp : (struct svalue *)0);
    }
  else
    {
      vec = 0;
    }
  pop_n_elems(num_arg);
  if (vec)
    {
      push_vector(vec);	/* This will make ref count == 2 */
      vec->ref--;
    }
  else
    {
      push_number(0);
    }
}

void
f_find_call_out(num_arg, instruction)
int num_arg, instruction;
{
  i = find_call_out(current_object, sp->u.string);
  pop_stack();
  push_number(i);
}

void
f_find_living(num_arg, instruction)
int num_arg, instruction;
{
  ob = find_living_object(sp->u.string, 0);
  pop_stack();
  if (!ob)
    push_number(0);
  else
    push_object(ob);
}

void
f_find_object(num_arg, instruction)
int num_arg, instruction;
{
    ob = find_object2(sp->u.string);
    pop_stack();
    if (ob)
    {
        if (object_visible(ob))
            push_object(ob);
          else
            push_number(0);
    }
  else
    push_number(0);
}

void
f_find_player(num_arg, instruction)
int num_arg, instruction;
{
  ob = find_living_object(sp->u.string, 1);
  pop_stack();
  if (!ob)
    push_number(0);
  else
    push_object(ob);
}

/*
  OBSOLETE
	How much do we need this?  It would be easy to make into
	a simul_efun...
	--Sulam
*/

void
f_first_inventory(num_arg, instruction)
int num_arg, instruction;
{
  ob = first_inventory(sp);
  pop_stack();
  if (ob)
    push_object(ob);
  else
    push_number(0);
}

void
f_function_exists(num_arg, instruction)
int num_arg, instruction;
{
  char *str, *res;

  str = function_exists((sp-1)->u.string, sp->u.ob);
  pop_n_elems(2);
  if (str)
    {
      res = (char *)add_slash(str);
      if (str = strrchr (res, '.'))
	*str = 0;
      push_malloced_string(res);
    }
  else
    {
      push_number(0);
    }
}

void
f_get_char(num_arg, instruction)
int num_arg, instruction;
{
  struct svalue *arg;
  int flag = 1;

  arg = sp - num_arg + 1;
  if (num_arg == 1 || (sp->type == T_NUMBER && sp->u.number == 0))
    flag = 0;
  i = get_char(arg[0].u.string, flag);
  pop_n_elems(num_arg);
  push_number(i);
}

void
f_get_dir(num_arg, instruction)
int num_arg, instruction;
{
  struct vector *vec;

  vec = get_dir((sp-1)->u.string, sp->u.number);
  pop_n_elems(2);
  if (vec)
    {
      push_vector(vec);
      vec->ref--;		/* resets ref count */
    }
  else
      push_number(0);
}

void
f_geteuid(num_arg, instruction)
int num_arg, instruction;
{
  ob = sp->u.ob;
  if (ob->euid)
    {
      char *tmp;
      
      tmp = ob->euid->name;
      pop_stack();
      push_string(tmp, STRING_CONSTANT);
    }
  else
    {
      pop_stack();
      push_number(0);
    }
}

void
f_getuid(num_arg, instruction)
int num_arg, instruction;
{
    char *tmp;

  ob = sp->u.ob;
#ifdef DEBUG
  if (ob->uid == NULL)
    fatal("UID is a null pointer\n");
#endif
    tmp = ob->uid->name;
    pop_stack();
    push_string(tmp, STRING_CONSTANT);
}

void
f_implode(num_arg, instruction)
int num_arg, instruction;
{
  char *str;

  check_for_destr((sp-1)->u.vec);
  str = implode_string((sp-1)->u.vec, sp->u.string);
  pop_n_elems(2);
  if (str)
      push_malloced_string(str);
   else
      push_number(0);
}

void
f_in_edit(num_arg, instruction)
int num_arg, instruction;
{
  i = sp->u.ob->interactive && sp->u.ob->interactive->ed_buffer;
  pop_stack();
  if (i)
    push_number(1);
  else
    push_number(0);
}

void
f_in_input(num_arg, instruction)
int num_arg, instruction;
{
  i = sp->u.ob->interactive && sp->u.ob->interactive->input_to;
  pop_stack();
  if (i)
    push_number(1);
  else
    push_number(0);
}

void
f_inherit_list(num_arg, instruction)
int num_arg, instruction;
{
  struct vector *vec;
  extern struct vector *inherit_list PROT((struct object *));

  vec = inherit_list(sp->u.ob);
  pop_stack();
  push_vector(vec);
  vec->ref--;			/* reset ref count */
}

void
f_input_to(num_arg, instruction)
int num_arg, instruction;
{
  struct svalue *arg;
  int flag, tmp;

  arg = sp - num_arg + 1;	/* Points arg at first argument. */
  if ((num_arg < 2) || (arg[1].type != T_NUMBER))
    {
      tmp = 0;
      flag = 0;
    }
  else
    {
      tmp = 1;	 
      num_arg--;		/* Don't count the flag as an arg */
      flag = arg[1].u.number;
    }
  num_arg--;			/* Don't count the name of the func either. */
  i = input_to(arg[0].u.string, flag, num_arg, &arg[1 + tmp]);
  pop_n_elems(num_arg + 1 + tmp);
  push_number(i);
}

void
f_interactive(num_arg, instruction)
int num_arg, instruction;
{
  i = (int)sp->u.ob->interactive;
  pop_stack();
  push_number(i);
}

void
f_intp(num_arg, instruction)
int num_arg, instruction;
{
  if (sp->type == T_NUMBER)
    assign_svalue(sp, &const1);
  else
    assign_svalue(sp, &const0);
}

void
f_keys(num_arg, instruction)
int num_arg, instruction;
{
  struct vector *vec;

  vec = mapping_indices(sp->u.map);
  eval_cost += vec->size;
  pop_stack();
  push_vector(vec);
  vec->ref--;			/* resets ref count */
}

void
f_values(num_arg, instruction)
int num_arg, instruction;
{
  struct vector *vec;

  vec = mapping_values(sp->u.map);
  eval_cost += vec->size;
  pop_stack();
  push_vector(vec);
  vec->ref--;			/* resets ref count */
}

#ifdef F_LINK
void
f_link(num_arg, instruction)
int num_arg, instruction;
{
  struct svalue *ret;

  push_string((sp-1)->u.string, STRING_CONSTANT);
  push_string(sp->u.string, STRING_CONSTANT);
  ret = apply_master_ob("valid_link", 2);
  if (!IS_ZERO(ret))
    i = do_rename((sp-1)->u.string, sp->u.string, F_LINK);
  pop_n_elems(2);
  push_number(i);
}
#endif /* F_LINK */

void
f_living(num_arg, instruction)
int num_arg, instruction;
{
  if (sp->u.ob->flags & O_ENABLE_COMMANDS)
    assign_svalue(sp, &const1);
  else
    assign_svalue(sp, &const0);
}

void
f_localtime(num_arg, instruction)
    int num_arg, instruction;
{
    struct tm *tm;
    struct vector *vec;
    time_t lt;

    lt = sp->u.number;
    tm = localtime(&lt);

    vec = allocate_array(10);
    vec->item[LT_SEC].type = T_NUMBER;
    vec->item[LT_SEC].u.number = tm->tm_sec;
    vec->item[LT_MIN].type = T_NUMBER;
    vec->item[LT_MIN].u.number = tm->tm_min;
    vec->item[LT_HOUR].type = T_NUMBER;
    vec->item[LT_HOUR].u.number = tm->tm_hour;
    vec->item[LT_MDAY].type = T_NUMBER;
    vec->item[LT_MDAY].u.number = tm->tm_mday;
    vec->item[LT_MON].type = T_NUMBER;
    vec->item[LT_MON].u.number = tm->tm_mon;
    vec->item[LT_YEAR].type = T_NUMBER;
    vec->item[LT_YEAR].u.number = tm->tm_year + 1900;
    vec->item[LT_WDAY].type = T_NUMBER;
    vec->item[LT_WDAY].u.number = tm->tm_wday;
    vec->item[LT_YDAY].type = T_NUMBER;
    vec->item[LT_YDAY].u.number = tm->tm_yday;
    vec->item[LT_GMTOFF].type = T_NUMBER;
    vec->item[LT_ZONE].type = T_STRING;
    vec->item[LT_ZONE].subtype = STRING_MALLOC;
#ifdef BSD42 /* look in port.h */
	/* 4.2 BSD doesn't seem to provide any way to get these last two values */
    vec->item[LT_GMTOFF].type = T_NUMBER;
	vec->item[LT_GMTOFF].u.number = 0;
    vec->item[LT_ZONE].type = T_NUMBER;
	vec->item[LT_ZONE].u.number = 0;
#else /* BSD42 */
#if (defined(hpux) || defined(_SEQUENT_) || defined(_AIX) || defined(SVR4))
    if (!tm->tm_isdst) {
        vec->item[LT_GMTOFF].u.number = timezone;
        vec->item[LT_ZONE].u.string = string_copy(tzname[0]);
    } else {
#if (defined(_AIX) || defined(hpux))
        vec->item[LT_GMTOFF].u.number = timezone;
#else
        vec->item[LT_GMTOFF].u.number = altzone;
#endif
        vec->item[LT_ZONE].u.string = string_copy(tzname[1]);
    }
#else
    vec->item[LT_GMTOFF].u.number = tm->tm_gmtoff;
    vec->item[LT_ZONE].u.string = tm->tm_zone;
#endif
#endif /* BSD42 */
    pop_stack();
    push_vector(vec);
    vec->ref--;
}

void
f_log_file(num_arg, instruction)
int num_arg, instruction;
{
	if (IS_ZERO(sp)) {
		bad_arg(2, instruction);
		pop_stack();
	} else {
		log_file((sp-1)->u.string, sp->u.string);
		pop_stack();
	}
}

void
f_lower_case(num_arg, instruction)
int num_arg, instruction;
{
  char *str = string_copy(sp->u.string);
  for (i = strlen(str)-1; i>=0; i--)
    if (isalpha(str[i]))
      str[i] |= 'a' - 'A';
  pop_stack();
  push_malloced_string(str);
}


void f_malloc_status(num_arg, instruction)
int num_arg, instruction;
{
#ifdef DO_MSTATS
	void show_mstats PROT((char *));
#endif
#if (defined(WRAPPEDMALLOC) || defined(DEBUGMALLOC))
    void dump_malloc_data();
#endif

	if (using_bsd_malloc) {
		add_message("Using BSD malloc.\n");
	}
	if (using_smalloc) {
		add_message("Using Smalloc.\n");
	}
#ifdef DO_MSTATS
	show_mstats("malloc_status()");
#endif
#if (defined(WRAPPEDMALLOC) || defined(DEBUGMALLOC))
    dump_malloc_data();
#endif
#ifdef SYSMALLOC
	if (!using_bsd_malloc && !using_smalloc) {
		add_message("Using system malloc.\n");
	}
#endif
#ifdef GMALLOC
    add_message("Using Gnu malloc.\n");
#endif
    push_number(0);
}

void
f_map_delete(num_arg, instruction)
int num_arg, instruction;
{
  mapping_delete((sp-1)->u.map,sp);
  pop_stack(); /* all functions must leave exactly 1 element on stack */
}


void
f_mapp(num_arg, instruction)
int num_arg, instruction;
{
  if (sp->type == T_MAPPING)
    assign_svalue(sp, &const1);
  else
    assign_svalue(sp, &const0);
}

void
f_map_array(num_arg, instruction)
int num_arg, instruction;
{
  struct vector *res;
  struct mapping *map = (struct mapping *) 0;
  struct svalue *arg;

  arg = sp - num_arg + 1; ob = 0;

  if (arg[2].type == T_OBJECT)
    ob = arg[2].u.ob;
  else if (arg[2].type == T_STRING) 
   {
     ob = find_object(arg[2].u.string);
     if (ob && !object_visible(ob)) ob = 0;
   }

  if (!ob)
    bad_arg (3, F_MAP_ARRAY);

  if (arg[0].type == T_POINTER) {
    check_for_destr(arg[0].u.vec);
    res = map_array (arg[0].u.vec, arg[1].u.string, ob,
		     num_arg > 3 ? sp : (struct svalue *)0);
  } else if (arg[0].type == T_MAPPING) {
    map = map_mapping (arg[0].u.map, arg[1].u.string, ob,
		       num_arg > 3 ? sp : (struct svalue *) 0);
  } else {
    res = 0;
  }
  pop_n_elems (num_arg);
  if (map)
  {
    push_mapping(map);
    map->ref--;
  }
  else if (res)
  {
    push_vector (res);		/* This will make ref count == 2 */
    res->ref--;
  }
  else
    push_number (0);
}

void
f_master(num_arg, instruction)
int num_arg, instruction;
{
  assert_master_ob_loaded("master()");
  push_object(master_ob);
}

void
f_member_array(num_arg, instruction)
int num_arg, instruction;
{
  struct vector *v;
  struct svalue *find;
  int ncmp = 0;

  if (num_arg > 2 && sp->type == T_NUMBER &&
      sp->u.number && (sp-2)->type == T_STRING) {
    ncmp = strlen((sp-2)->u.string);
    v = (sp-1)->u.vec;
    find = (sp-2);
  } else {
    v = sp->u.vec;
    find = (sp-1);
  }
  check_for_destr(v);
  for (i=0; i < v->size; i++)
  {
    if (v->item[i].type != find->type)
      continue;
    switch(find->type)
      {
      case T_STRING:
        if (ncmp) {
          if (strncmp(find->u.string, v->item[i].u.string, ncmp))
            break;
        } else if (strcmp(find->u.string, v->item[i].u.string) == 0)
	  break;
	continue;
      case T_POINTER:
	if (find->u.vec == v->item[i].u.vec)
	  break;
	continue;
      case T_OBJECT:
	if (find->u.ob == v->item[i].u.ob)
	  break;
	continue;
      case T_NUMBER:
	if (find->u.number == v->item[i].u.number)
	  break;
	continue;
      case T_MAPPING:
	if (find->u.map == v->item[i].u.map)
	  break;
	continue;
      default:
	fatal("Bad type to member_array(): %d\n", (sp-1)->type);
      }
    break;
  }
  if (i == v->size)
    i = -1;			/* Return -1 for failure */
  pop_n_elems(num_arg);
  push_number(i);
}

void
f_message(num_arg, instruction)
int num_arg, instruction;
{
  int freeuse = 0, freeavoid = 0;
  struct vector *use, *avoid;
  struct svalue *args;
  struct object *ob;
  static struct vector vtmp1 = { 1,1,
#ifdef DEBUG
				   1,
#endif
                                   NULL};
  static struct vector vtmp2 = { 1,1,
#ifdef DEBUG
				   1,
#endif
                                   NULL};
	
  args = sp - num_arg + 1;
  if(args[2].type == T_OBJECT)
    {
      vtmp1.item[0].type = T_OBJECT;
      vtmp1.item[0].u.ob = args[2].u.ob;
      add_ref(args[2].u.ob,"message");
      use = &vtmp1;
    }
  else if(args[2].type == T_STRING)
    {
      ob = find_object (args[2].u.string);
   if (!ob || !object_visible(ob))
	error ("message: Couldn't find %s\n",args[2].u.string);
      vtmp1.item[0].type = T_OBJECT;
      vtmp1.item[0].u.ob = ob;
      add_ref (ob, "message");
      use = &vtmp1;
    }
  else
    {
      if (!args[2].u.vec)
	{
	  check_legal_string(args[0].u.string);
	  add_message(args[0].u.string);
	  pop_n_elems(num_arg);
	  push_number (0);
	  return;
	}
      if(args[2].u.vec->ref > 1)
	{
	  use = slice_array(args[2].u.vec,0,args[2].u.vec->size-1);
	  freeuse = 1;
	}
      else
	use = args[2].u.vec;
    }
  if (num_arg == 4)
    {
      if (args[3].type == T_OBJECT)
	{
	  vtmp2.item[0].type = T_OBJECT;
	  vtmp2.item[0].u.ob = args[3].u.ob;
	  add_ref(args[3].u.ob,"message");
	  avoid = &vtmp2;
	}
      else if (args[3].u.vec)
	{
	  if (args[3].u.vec->ref > 1)
	    {
	      avoid = slice_array(args[3].u.vec,0,args[3].u.vec->size-1);
	      freeavoid = 1;
	    }
	  else
            avoid = args[3].u.vec;
	}
      else avoid = null_array();
    }
  else
    avoid = null_array();
  do_message(args[0].u.string,args[1].u.string,use,avoid);
  if (freeuse) {
    free_vector(use);
  }
  if (freeavoid) {
    free_vector(avoid);
  }        
  pop_n_elems(num_arg);
  push_number (0);
  return;
}

void
f_mkdir(num_arg, instruction)
int num_arg, instruction;
{
  char *path;

  path = check_valid_path(sp->u.string, current_object, "mkdir", 1);
  if (path == 0 || mkdir(path, 0770) == -1)
    assign_svalue(sp, &const0);
  else
    assign_svalue(sp, &const1);
}

void
f_move_object(num_arg, instruction)
int num_arg, instruction;
{
  struct object *o1, *o2;

  if (sp->type == T_OBJECT)
    o2 = sp->u.ob;
  else
    {
      o2 = find_object(sp->u.string);
        if (!o2 || !object_visible(o2))
	error("move_object failed\n");
    }
  if (num_arg == 1)
    o1 = current_object;
  else
  {
    o1 = (sp-1)->u.ob;
    pop_stack();
  }
  move_object(o1, o2);
}

void
f_mud_name(num_arg, instruction)
int num_arg, instruction;
{
  push_string(MUD_NAME, STRING_MALLOC);
}

void f_mud_status(num_arg, instruction)
int num_arg, instruction;
{
  int tot, res, verbose = 0;
  extern char *reserved_area;
  extern int tot_alloc_object, tot_alloc_sentence,
  tot_alloc_object_size, num_arrays, total_array_size,
  total_mapping_size;
  extern int total_prog_block_size;
#ifdef COMM_STAT
  extern int add_message_calls, inet_packets, inet_volume;
#endif

  verbose = sp->u.number;
  pop_stack();
  if (reserved_area)
    res = RESERVED_SIZE;
  else
    res = 0;
#ifdef COMM_STAT
  if (verbose) {
     add_message ("add_message statistics\n");
     add_message ("------------------------------\n");
     add_message("Calls to add_message: %d   Packets: %d   Average packet size: %f\n\n",add_message_calls,inet_packets,(float)inet_volume/inet_packets);
  }
#endif
  if (!verbose) {
    add_message("Sentences:\t\t\t%8d %8d\n", tot_alloc_sentence,
		tot_alloc_sentence * sizeof (struct sentence));
    add_message("Objects:\t\t\t%8d %8d\n",
		tot_alloc_object, tot_alloc_object_size);
    add_message("Arrays:\t\t\t\t%8d %8d\n", num_arrays,
		total_array_size);
  }
  if (verbose) {
     stat_living_objects();
#ifdef F_CACHE_STATS
     print_cache_stats();
#endif
  }
  tot = total_prog_block_size +
    total_array_size +
      total_mapping_size +
	tot_alloc_object_size +
	  show_otable_status(verbose) +
	    heart_beat_status(verbose) +
	      add_string_status(verbose) +
		print_call_out_usage(verbose) +
		  res;

  if (!verbose) {
    add_message("\t\t\t\t\t --------\n");
    add_message("Total:\t\t\t\t\t %8d\n", tot);
  } else {
    ;
  }
     
  push_number(0);
}

void
f_new(num_arg, instruction)
int num_arg, instruction;
{
  struct object *ob;

  ob = clone_object(sp->u.string);
  pop_stack();
  if (ob)
  {
    sp++;
    sp->type = T_OBJECT;
    sp->u.ob = ob;
    add_ref(ob, "F_NEW");
  }
  else
    push_number(0);
}

/*
   OBSOLETE
   	Is this neccessary either? It could be a simul_efun. -SH
*/
void
f_next_inventory(num_arg, instruction)
int num_arg, instruction;
{
  ob = sp->u.ob;
  pop_stack();
  ob = ob->next_inv;
  while (ob)
  {
    if (ob->flags & O_HIDDEN)
    {
      if (object_visible(ob))
      {
        push_object(ob);
        return;
      }
    } else
    {
      push_object(ob);
      return;
    }
    ob = ob->next_inv;
  }
    push_number(0);
}

void
f_next_living(num_arg, instruction)
int num_arg, instruction;
{
  ob = sp->u.ob->next_hashed_living;
  pop_stack();
  if (!ob)
    push_number(0);
  else
    push_object(ob);
}

void
f_notify_fail(num_arg, instruction)
int num_arg, instruction;
{
  set_notify_fail_message(sp->u.string);
  /* Return the argument */
}

void
f_nullp(num_arg, instruction)
int num_arg, instruction;
{
  if (IS_NULL(sp))
    assign_svalue(sp, &const1);
  else
    assign_svalue(sp, &const0);
}

void
f_objectp(num_arg, instruction)
int num_arg, instruction;
{
  if (sp->type == T_OBJECT)
    assign_svalue(sp, &const1);
  else
    assign_svalue(sp, &const0);
}

#ifdef OPCPROF

void
f_opcprof(num_arg, instruction)
int num_arg, instruction;
{
	char *fn = "/OPCPROF";

	if (num_arg == 1) {
		fn = sp->u.string;
	}
	opcdump(fn);
	if (num_arg == 1) {
		pop_stack();
	}
	push_number(0);
}

#endif

void
f_pointerp(num_arg, instruction)
int num_arg, instruction;
{
  if (sp->type == T_POINTER)
    assign_svalue(sp, &const1);
  else
    assign_svalue(sp, &const0);
}

void
f_present(num_arg, instruction)
int num_arg, instruction;
{
  struct svalue *arg = sp - num_arg + 1;
  ob = object_present(arg, num_arg == 1 ? 0 : arg[1].u.ob);
  pop_n_elems(num_arg);
  if (ob)
    push_object(ob);
  else
    push_number(0);
}

void
f_previous_object(num_arg, instruction)
int num_arg, instruction;
{
  if (previous_ob == 0 || (previous_ob->flags & O_DESTRUCTED))
    push_number(0);
  else
    push_object(previous_ob);
}

#ifdef PRINTF
void
f_printf(num_arg, instruction)
int num_arg, instruction;
{
  add_message("%s", string_print_formatted((sp-num_arg+1)->u.string,
					   num_arg-1, sp-num_arg+2));
  pop_n_elems(num_arg-1);
}
#endif

void
f_process_string(num_arg, instruction)
int num_arg, instruction;
{
  extern char
    *process_string PROT((char *));

  char *str;

  str = process_string(sp->u.string);
  if (str != sp->u.string)
    {
      pop_stack();
      push_malloced_string(str);
    }
}

void
f_query_host_name(num_arg, instruction)
int num_arg, instruction;
{
  extern char *query_host_name();
  char *tmp;

  tmp = query_host_name();
  if (tmp)
    push_string(tmp, STRING_CONSTANT);
  else
    push_number(0);
}

void
f_query_idle(num_arg, instruction)
int num_arg, instruction;
{
  i = query_idle(sp->u.ob);
  pop_stack();
  push_number(i);
}

void
f_query_ip_name(num_arg, instruction)
int num_arg, instruction;
{
  extern char *query_ip_name PROT((struct object *));
  char *tmp;

  if (num_arg == 1 && sp->type != T_OBJECT)
    error("Bad optional argument to query_ip_name()\n");
  tmp = query_ip_name(num_arg ? sp->u.ob : 0);
  if (num_arg)
    pop_stack();
  if (tmp == 0)
    push_number(0);
  else
    push_string(tmp, STRING_MALLOC);
}

void
f_query_ip_number(num_arg, instruction)
int num_arg, instruction;
{
  extern char *query_ip_number PROT((struct object *));
  char *tmp;

  if (num_arg == 1 && sp->type != T_OBJECT)
    error("Bad optional argument to query_ip_number()\n");
  tmp = query_ip_number(num_arg ? sp->u.ob : 0);
  if (num_arg)
    pop_stack();
  if (tmp == 0)
    push_number(0);
  else
    push_string(tmp, STRING_MALLOC);
}

void
f_query_load_average(num_arg, instruction)
int num_arg, instruction;
{
  push_string(query_load_av(), STRING_MALLOC);
}

void
f_query_snoop(num_arg, instruction)
int num_arg, instruction;
{
  if (command_giver == 0 || sp->u.ob->interactive == 0 ||
      (command_giver->flags & O_DESTRUCTED))
    {
      assign_svalue(sp, &const0);
      return;
    }
  assert_master_ob_loaded("query_snoop()");
  if (current_object == master_ob)
    ob = query_snoop(sp->u.ob);
  else
    ob = 0;
  pop_stack();
  if (ob)
    push_object(ob);
  else
    push_number(0);
}

void
f_query_verb(num_arg, instruction)
int num_arg, instruction;
{
  if (last_verb == 0)
    {
      push_number(0);
      return;
    }
  push_string(last_verb, STRING_CONSTANT);
}

void
f_random(num_arg, instruction)
int num_arg, instruction;
{
  if (sp->u.number <= 0)
    {
      sp->u.number = 0;
      return;
    }
  sp->u.number = random_number(sp->u.number);
}

void
f_read_bytes(num_arg, instruction)
int num_arg, instruction;
{
  char *str;
  struct svalue *arg = sp- num_arg + 1;
  int start = 0, len = 0;

  if (num_arg > 1)
    start = arg[1].u.number;
  if (num_arg == 3)
    {
      if (arg[2].type != T_NUMBER)
	bad_arg(2, instruction);
      len = arg[2].u.number;
    }
  str = read_bytes(arg[0].u.string, start, len);
  pop_n_elems(num_arg);
  if (str == 0)
    push_number(0);
  else
    {
      push_string(str, STRING_MALLOC);
      FREE(str);
    }
}

void
f_read_file(num_arg, instruction)
int num_arg, instruction;
{
  char *str;
  struct svalue *arg = sp- num_arg + 1;
  int start = 0, len = 0;

  if (num_arg > 1)
    start = arg[1].u.number;
  if (num_arg == 3)
    {
      if (arg[2].type != T_NUMBER)
	bad_arg(2, instruction);
      len = arg[2].u.number;
    }

  str = read_file(arg[0].u.string, start, len);
  pop_n_elems(num_arg);
  if (str == 0)
    push_number(0);
  else
    {
      push_string(str, STRING_MALLOC);
      FREE(str);
    }
}

void
f_receive(num_arg, instruction)
int num_arg, instruction;
{
	if (current_object->interactive) {
		struct object *save_command_giver = command_giver;

		check_legal_string(sp->u.string);
		command_giver = current_object;
		add_message("%s", sp->u.string);
		command_giver = save_command_giver;
		assign_svalue(sp, &const1);
	} else {
		assign_svalue(sp, &const0);
	}
}

void
f_regexp(num_arg, instruction)
int num_arg, instruction;
{
  struct vector *v;

  v = match_regexp((sp-1)->u.vec, sp->u.string);
  pop_n_elems(2);
  if (v == 0)
    push_number(0);
  else
    {
      push_vector(v);
      v->ref--;			/* Will make ref count == 1 */
    }
}

void
f_remove_action(num_arg, instruction)
int num_arg, instruction;
{
#ifdef DISCWORLD
  remove_action((sp-1)->u.string, sp->u.ob);
#else
  remove_action((sp-1)->u.string, sp->u.string);
#endif
  pop_stack();
}

void
f_remove_call_out(num_arg, instruction)
int num_arg, instruction;
{
  int i;

  i = remove_call_out(current_object, sp->u.string);
  pop_stack();
  push_number(i);
}

#ifdef F_RENAME
void
f_rename(num_arg, instruction)
int num_arg, instruction;
{
  int i;

  i = do_rename((sp-1)->u.string, sp->u.string, F_RENAME);
  pop_n_elems(2);
  push_number(i);
}
#endif /* F_RENAME */

void
f_replace_string(num_arg, instruction)
    int num_arg, instruction;
{
    int plen, rlen, dlen;
    char *src, *pattern, *replace, *dst1, *dst2;

    if (IS_ZERO(sp)) { /* first and second args checked elsewhere */
    	bad_arg(3, F_REPLACE_STRING);
    	pop_n_elems(3);
    	return;
    }
    src = (sp-2)->u.string;
    pattern = (sp-1)->u.string;
    replace = sp->u.string;
    dst2 = dst1 = (char *)MALLOC(max_string_length);

    plen = strlen(pattern);
    rlen = strlen(replace);
    dlen = 0;

    if (plen == 0) {
	strcpy(dst2, src);
    } else {
	while (*src != '\0') {
	    if (strncmp(src, pattern, plen) == 0) {
		if (rlen != 0) {
		    if (max_string_length - dlen <= rlen) {
			pop_n_elems(3);
			push_svalue(&const0u);
			FREE(dst1);
			return;
		    }
		    strncpy(dst2, replace, rlen);
		    dst2 += rlen;
		    dlen += rlen;
		}
		src += plen;
	    } else {
		if (max_string_length - dlen <= 1) {
		    pop_n_elems(3);
		    push_svalue(&const0u);
		    FREE(dst1);
		    return;
		}
		*dst2++ = *src++;
		dlen++;
	    }
	}
	*dst2 = '\0';
    }
    pop_n_elems(3);
    push_string(dst1, STRING_MALLOC);
    FREE(dst1);
}

void
f_restore_object(num_arg, instruction)
int num_arg, instruction;
{
  i = restore_object(current_object, sp->u.string);
  pop_stack();
  push_number(i);
}

void
f_rm(num_arg, instruction)
int num_arg, instruction;
{
  int i;

  i = remove_file(sp->u.string);
  pop_stack();
  push_number(i);
}

void
f_rmdir(num_arg, instruction)
int num_arg, instruction;
{
  char *path;

  path = check_valid_path(sp->u.string, current_object, "rmdir", 1);
  if (path == 0 || rmdir(path) == -1)
    assign_svalue(sp, &const0);
  else
    assign_svalue(sp, &const1);
}

void add_mapping_pair(m, key, value)
struct mapping *m;
char *key;
int value;
{
	struct svalue *s, lv;

	lv.type = T_STRING;
	lv.subtype = STRING_CONSTANT;
	lv.u.string = key;
	s = find_for_insert(m, &lv, 1);
	s->type = T_NUMBER;
	s->subtype = 0;
	s->u.number = value;
}

#ifdef RUSAGE

void
f_rusage(num_arg, instruction)
int num_arg, instruction;
{
  struct rusage rus;
  struct mapping *m;
  long usertime, stime;
  int maxrss;

  if (getrusage(RUSAGE_SELF, &rus) < 0) {
    m = allocate_mapping(0);
  } else {
    usertime = rus.ru_utime.tv_sec * 1000 + rus.ru_utime.tv_usec / 1000;
    stime = rus.ru_stime.tv_sec * 1000 + rus.ru_stime.tv_usec / 1000;
    maxrss = rus.ru_maxrss;
#ifdef sun
    maxrss *= getpagesize() / 1024;
#endif
    m = allocate_mapping(16);
    add_mapping_pair(m, "usertime", usertime);
    add_mapping_pair(m, "stime", stime);
    add_mapping_pair(m, "maxrss", maxrss);
    add_mapping_pair(m, "ixrss", rus.ru_ixrss);
    add_mapping_pair(m, "idrss", rus.ru_idrss);
    add_mapping_pair(m, "isrss", rus.ru_isrss);
    add_mapping_pair(m, "minflt", rus.ru_minflt);
    add_mapping_pair(m, "majflt", rus.ru_majflt);
    add_mapping_pair(m, "nswap", rus.ru_nswap);
    add_mapping_pair(m, "inblock", rus.ru_inblock);
    add_mapping_pair(m, "oublock", rus.ru_oublock);
    add_mapping_pair(m, "msgsnd", rus.ru_msgsnd);
    add_mapping_pair(m, "msgrcv", rus.ru_msgrcv);
    add_mapping_pair(m, "nsignals", rus.ru_nsignals);
    add_mapping_pair(m, "nvcsw", rus.ru_nvcsw);
    add_mapping_pair(m, "nivcsw", rus.ru_nivcsw);
  }
  m->ref--;
  push_mapping(m);
}
#else

#ifdef TIMES /* has times() but not getrusage() */

/*
  warning times are reported in processor dependent units of time.
  see man pages for 'times' to figure out how long a tick is on your system.
*/

void
f_rusage(num_arg, instruction)
int num_arg, instruction;
{
	struct mapping *m;
	struct tms t;

	times(&t);
	m = allocate_mapping(2);
    add_mapping_pair(m, "usertime", t.tms_utime);
    add_mapping_pair(m, "stime", t.tms_stime);
	m->ref--;
	push_mapping(m);
}

#endif /* TIMES */

#endif /* RUSAGE */

void
f_save_object(num_arg, instruction)
int num_arg, instruction;
{
  save_object(current_object, sp->u.string);
  /* The argument is returned */
}

#ifdef F_SAY
void
f_say(num_arg, instruction)
int num_arg, instruction;
{
  static struct {
    struct vector v;
    struct svalue second_item[1];
  } vtmp = { { 2, 1,
#ifdef DEBUG
		 1,
#endif
		 {(mudlib_stats_t *)NULL,
		    (mudlib_stats_t *)NULL},
		 { { T_NUMBER } } }, { { T_OBJECT } }
	   };
	
  if (num_arg == 1)
    {
       vtmp.v.item[0].type = T_NUMBER; /* this marks the place for the
					  command_giver  */
       vtmp.v.item[1].type = T_NUMBER; /* will not match any object... */
       say(sp, &vtmp.v);
    } 
  else
    {
       vtmp.v.item[0].type = T_NUMBER;
       vtmp.v.item[1].type = T_OBJECT;
       vtmp.v.item[1].u.ob = sp->u.ob;
       add_ref(sp->u.ob, "say");
       say(sp-1, &vtmp.v);
       pop_stack();
    }
}
#endif /* F_SAY */

void
f_set_bit(num_arg, instruction)
int num_arg, instruction;
{
  char *str;
  int len, old_len, ind;

  if (sp->u.number > MAX_BITS)
    error("set_bit: too big bit number: %d\n", sp->u.number);
  len = strlen((sp-1)->u.string);
  old_len = len;
  ind = sp->u.number/6;
  if (ind >= len)
    len = ind + 1;
  str = XALLOC(len+1);
  str[len] = '\0';
  if (old_len)
    memcpy(str, (sp-1)->u.string, old_len);
  if (len > old_len)
    memset(str + old_len, ' ', len - old_len);
  if (str[ind] > 0x3f + ' ' || str[ind] < ' ')
    error("Illegal bit pattern in set_bit character %d\n", ind);
  str[ind] = ((str[ind] - ' ') | (1 << (sp->u.number % 6))) + ' ';
  pop_n_elems(2);
  sp++;
  sp->u.string = str;
  sp->subtype = STRING_MALLOC;
  sp->type = T_STRING;
}

void
f_set_heart_beat(num_arg, instruction)
int num_arg, instruction;
{
  i = set_heart_beat(current_object, sp->u.number);
  sp->u.number = i;
}

void
f_set_hide(num_arg, instruction)
int num_arg, instruction;
{
	struct svalue *ret;

	push_object(current_object);
	ret = apply_master_ob("valid_hide", 1);
	if (IS_ZERO(ret)) {
		return;
	}
	if (sp->u.number) {
		if (!(current_object->flags & O_HIDDEN) && current_object->interactive)
			num_hidden++;
		current_object->flags |= O_HIDDEN;
	}
	else {
		if ((current_object->flags & O_HIDDEN) && current_object->interactive)
			num_hidden--;
		current_object->flags &= ~O_HIDDEN;
	}
}

void
f_set_light(num_arg, instruction)
int num_arg, instruction;
{
  struct object *o1;

  add_light(current_object, sp->u.number);
  o1 = current_object;
  while(o1->super)
    o1 = o1->super;
  sp->u.number = o1->total_light;
}

void
f_set_living_name(num_arg, instruction)
int num_arg, instruction;
{
  set_living_name(current_object, sp->u.string);
}

void
f_seteuid(num_arg, instruction)
int num_arg, instruction;
{
  struct svalue *ret;

  if (sp->type == T_NUMBER) {
    if (sp->u.number != 0)
      bad_arg(1, F_SETEUID);
    current_object->euid = NULL;
    pop_stack();
    push_number(1);
    return;
  }
  argp = sp;
  if (argp->type != T_STRING)
    bad_arg(1, F_SETEUID);
  push_object(current_object);
  push_string(argp->u.string, STRING_CONSTANT);
  ret = apply_master_ob("valid_seteuid", 2);
  if (ret == 0 || ret->type != T_NUMBER || ret->u.number != 1) {
    pop_stack();
    push_number(0);
    return;
  }
  current_object->euid = add_uid(argp->u.string);
  pop_stack();
  push_number(1);
}

#ifdef F_SETUID
void
f_setuid(num_arg, instruction)
int num_arg, instruction;
     struct svalue *sp;
     int num_arg;
     int instruction;
{
  setuid();
  push_number(0);
}
#endif /* F_SETUID */

#ifndef NO_SHADOWS
void
f_shadow(num_arg, instruction)
int num_arg, instruction;
{
  ob = (sp-1)->u.ob;
  if (sp->u.number == 0) {
    ob = ob->shadowed;
    pop_n_elems(2);
    if (ob)
      push_object(ob);
    else
      push_number(0);
    return;
  }
  if (validate_shadowing(ob))
  {
    /*
     * The shadow is entered first in the chain.
     */
    while (ob->shadowed)
      ob = ob->shadowed;
    current_object->shadowing = ob;
    ob->shadowed = current_object;
    pop_n_elems(2);
    push_object(ob);
    return;
  }
  pop_n_elems(2);
  push_number(0);
}
#endif

#ifdef F_SHOUT
void
f_shout(num_arg, instruction)
int num_arg, instruction;
{
  shout_string(sp->u.string);
}
#endif /* F_SHOUT */

void
f_shutdown(num_arg, instruction)
int num_arg, instruction;
{
	int exit_code = 0;

	if (num_arg) {
		exit_code = sp->u.number;
	}
	shutdownMudOS(exit_code);
	if (!num_arg) {
		push_number(0);
	}
}

void
f_sizeof(num_arg, instruction)
int num_arg, instruction;
{
  if (sp->type == T_MAPPING)
    i = sp->u.map->count;
  else if (sp->type == T_POINTER)
    i = sp->u.vec->size;
  else
    i = 0;
  pop_stack();
  push_number(i);
}

void
f_snoop(num_arg, instruction)
int num_arg, instruction;
{
  /* This one takes a variable number of arguments. It returns
   * 0 or an object.
   */
  if (!command_giver)
    {
      pop_n_elems(num_arg);
      push_number(0);
    }
  else
    {
      ob = 0;	       /* Do not remove this, it is not 0 by default */
      switch (num_arg)
	{
	case 1:
	  if (new_set_snoop(sp->u.ob, 0))
	    ob = sp->u.ob;
	  break;
	case 2:
	  if (new_set_snoop((sp-1)->u.ob, sp->u.ob))
	    ob = sp->u.ob;
	  break;
	default:
	  ob = 0;
	  break;
	}
      pop_n_elems(num_arg);
      if (ob)
	push_object(ob);
      else
	push_number(0);
    }
}

void
f_socket_create(num_arg, instruction)
    int num_arg, instruction;
{
    int fd;
    struct svalue *arg, *ret;
    struct vector *info;

    arg = sp - num_arg + 1;

    info = allocate_array(4);
    info->ref--;
    info->item[0].type = T_NUMBER;
    info->item[0].u.number = -1;
    assign_socket_owner(info->item + 1, current_object);
    info->item[2].type = T_STRING;
    info->item[2].subtype = STRING_CONSTANT;
    info->item[2].u.string = "N/A";
    info->item[3].type = T_NUMBER;
    info->item[3].u.number = -1;

    push_object(current_object);
    push_string("create", STRING_CONSTANT);
    push_vector(info);

    ret = apply_master_ob("valid_socket", 3);
    if (!IS_ZERO(ret)) {
	if (num_arg == 2)
	    fd = socket_create(arg[0].u.number, NULL, arg[1].u.string);
	else
	    fd = socket_create(arg[0].u.number, arg[1].u.string, arg[2].u.string);
	pop_n_elems(num_arg); /* pop both args off stack    */
	push_number(fd); /* push return int onto stack */
    } else {
	pop_n_elems(num_arg); /* pop both args off stack    */
	push_number(EESECURITY); /* Security violation attempted */
    }
}

void
f_socket_bind(num_arg, instruction)
    int num_arg, instruction;
{
    int fd, port;
    struct svalue *ret;
    struct vector *info;
    char addr[ADDR_BUF_SIZE];

    fd = (sp-1)->u.number;
    get_socket_address(fd, addr, &port);

    info = allocate_array(4);
    info->ref--;
    info->item[0].type = T_NUMBER;
    info->item[0].u.number = fd;
    assign_socket_owner(&info->item[1], get_socket_owner(fd));
    info->item[2].type = T_STRING;
    info->item[2].subtype = STRING_CONSTANT;
    info->item[2].u.string = addr;
    info->item[3].type = T_NUMBER;
    info->item[3].u.number = port;

    push_object(current_object);
    push_string("bind", STRING_CONSTANT);
    push_vector(info);

    ret = apply_master_ob("valid_socket", 3);
    if (!IS_ZERO(ret)) {
	i = socket_bind(fd, sp->u.number);
	pop_n_elems(2); /* pop both args off stack    */
	push_number(i); /* push return int onto stack */
    } else {
	pop_n_elems(2); /* pop both args off stack    */
	push_number(EESECURITY); /* Security violation attempted */
    }
}
  
void
f_socket_listen(num_arg, instruction)
     int num_arg, instruction;
{
    int fd, port;
    struct svalue *ret;
    struct vector *info;
    char addr[ADDR_BUF_SIZE];

    fd = (sp-1)->u.number;
    get_socket_address(fd, addr, &port);

    info = allocate_array(4);
    info->ref--;
    info->item[0].type = T_NUMBER;
    info->item[0].u.number = fd;
    assign_socket_owner(&info->item[1], get_socket_owner(fd));
    info->item[2].type = T_STRING;
    info->item[2].subtype = STRING_CONSTANT;
    info->item[2].u.string = addr;
    info->item[3].type = T_NUMBER;
    info->item[3].u.number = port;

    push_object(current_object);
    push_string("listen",STRING_CONSTANT);
    push_vector(info);

    ret = apply_master_ob("valid_socket",3);
    if (!IS_ZERO(ret)) {
	i = socket_listen(fd, sp->u.string);
	pop_n_elems(2); /* pop both args off stack    */
	push_number(i); /* push return int onto stack */
    } else {
	pop_n_elems(2); /* pop both args off stack    */
	push_number(EESECURITY); /* Security violation attempted */
    }
}

void
f_socket_accept(num_arg, instruction)
    int num_arg, instruction;
{
    int fd, port;
    struct svalue *ret;
    struct vector *info;
    char addr[ADDR_BUF_SIZE];
  
    fd = (sp-2)->u.number;
    get_socket_address(fd, addr, &port);

    info = allocate_array(4);
    info->ref--;
    info->item[0].type = T_NUMBER;
    info->item[0].u.number = fd;
    assign_socket_owner(&info->item[1], get_socket_owner(fd));
    info->item[2].type = T_STRING;
    info->item[2].subtype = STRING_CONSTANT;
    info->item[2].u.string = addr;
    info->item[3].type = T_NUMBER;
    info->item[3].u.number = port;

    push_object(current_object);
    push_string("accept", STRING_CONSTANT);
    push_vector(info);

    ret = apply_master_ob("valid_socket", 3);
    if (!IS_ZERO(ret)) {
	i = socket_accept(fd, (sp-1)->u.string, sp->u.string);
	pop_n_elems(3); /* pop both args off stack    */
	push_number(i); /* push return int onto stack */
    } else {
	pop_n_elems(3); /* pop both args off stack    */
	push_number(EESECURITY); /* Security violation attempted */
    }
}

void
f_socket_connect(num_arg, instruction)
     int num_arg, instruction;
{
    int fd, port;
    struct svalue *ret;
    struct vector *info;
    char addr[ADDR_BUF_SIZE];

    fd = (sp-3)->u.number;
    get_socket_address(fd, addr, &port);

    info = allocate_array(4);
    info->ref--;
    info->item[0].type = T_NUMBER;
    info->item[0].u.number = fd;
    assign_socket_owner(&info->item[1], get_socket_owner(fd));
    info->item[2].type = T_STRING;
    info->item[2].subtype = STRING_CONSTANT;
    info->item[2].u.string = addr;
    info->item[3].type = T_NUMBER;
    info->item[3].u.number = port;

    push_object(current_object);
    push_string("connect", STRING_CONSTANT);
    push_vector(info);

    ret = apply_master_ob("valid_socket", 3);
    if (!IS_ZERO(ret)) {
	i = socket_connect(fd, (sp-2)->u.string, (sp-1)->u.string,
		sp->u.string);
	pop_n_elems(4); /* pop all args off stack     */
	push_number(i); /* push return int onto stack */
    } else {
	pop_n_elems(4); /* pop all args off stack     */
	push_number(EESECURITY); /* Security violation attempted */
    }
}

void
f_socket_write(num_arg, instruction)
    int num_arg, instruction;
{
    int fd, port;
    struct svalue *arg, *ret;
    struct vector *info;
    char addr[ADDR_BUF_SIZE];

    arg = sp - num_arg + 1;
    fd = arg[0].u.number;
    get_socket_address(fd, addr, &port);

    info = allocate_array(4);
    info->ref--;
    info->item[0].type = T_NUMBER;
    info->item[0].u.number = fd;
    assign_socket_owner(&info->item[1], get_socket_owner(fd));
    info->item[2].type = T_STRING;
    info->item[2].subtype = STRING_CONSTANT;
    info->item[2].u.string = addr;
    info->item[3].type = T_NUMBER;
    info->item[3].u.number = port;

    push_object(current_object);
    push_string("write", STRING_CONSTANT);
    push_vector(info);

    ret = apply_master_ob("valid_socket", 3);
    if (!IS_ZERO(ret)) {
	i = socket_write(fd, &arg[1],
		(num_arg == 3) ? arg[2].u.string : (char *)NULL);
	pop_n_elems(num_arg); /* pop both args off stack    */
	push_number(i); /* push return int onto stack */
    } else {
	pop_n_elems(num_arg); /* pop both args off stack    */
	push_number(EESECURITY); /* Security violation attempted */
    }
}

void
f_socket_close(num_arg, instruction)
    int num_arg, instruction;
{
    int fd, port;
    struct svalue *ret;
    struct vector *info;
    char addr[ADDR_BUF_SIZE];

    fd = sp->u.number;
    get_socket_address(fd, addr, &port);

    info = allocate_array(4);
    info->ref--;
    info->item[0].type = T_NUMBER;
    info->item[0].u.number = fd;
    assign_socket_owner(&info->item[1], get_socket_owner(fd));
    info->item[2].type = T_STRING;
    info->item[2].subtype = STRING_CONSTANT;
    info->item[2].u.string = addr;
    info->item[3].type = T_NUMBER;
    info->item[3].u.number = port;

    push_object(current_object);
    push_string("close", STRING_CONSTANT);
    push_vector(info);

    ret = apply_master_ob("valid_socket", 3);
    if (!IS_ZERO(ret)) {
	i = socket_close(fd);
	pop_stack();    /* pop int arg off stack      */
	push_number(i); /* push return int onto stack */
    } else { 
	pop_stack();    /* pop int arg off stack      */
	push_number(EESECURITY); /* Security violation attempted */
    }
}

void
f_socket_release(num_arg, instruction)
    int num_arg, instruction;
{
    int fd, port;
    struct svalue *ret;
    struct vector *info;
    char addr[ADDR_BUF_SIZE];

    fd = (sp-2)->u.number;
    get_socket_address(fd, addr, &port);

    info = allocate_array(4);
    info->ref--;
    info->item[0].type = T_NUMBER;
    info->item[0].u.number = fd;
    assign_socket_owner(&info->item[1], get_socket_owner(fd));
    info->item[2].type = T_STRING;
    info->item[2].subtype = STRING_CONSTANT;
    info->item[2].u.string = addr;
    info->item[3].type = T_NUMBER;
    info->item[3].u.number = port;

    push_object(current_object);
    push_string("release", STRING_CONSTANT);
    push_vector(info);

    ret = apply_master_ob("valid_socket", 3);
    if (!IS_ZERO(ret)) {
	i = socket_release((sp-2)->u.number, (sp-1)->u.ob, sp->u.string);
	pop_n_elems(3); /* pop all args off stack     */
	push_number(i); /* push return int onto stack */
    } else {
	pop_n_elems(3); /* pop all args off stack     */
	push_number(EESECURITY); /* Security violation attempted */
    }
}

void
f_socket_acquire(num_arg, instruction)
    int num_arg, instruction;
{
    int fd, port;
    struct svalue *ret;
    struct vector *info;
    char addr[ADDR_BUF_SIZE];

    fd = (sp-1)->u.number;
    get_socket_address(fd, addr, &port);

    info = allocate_array(4);
    info->ref--;
    info->item[0].type = T_NUMBER;
    info->item[0].u.number = fd;
    assign_socket_owner(&info->item[1], get_socket_owner(fd));
    info->item[2].type = T_STRING;
    info->item[2].subtype = STRING_CONSTANT;
    info->item[2].u.string = addr;
    info->item[3].type = T_NUMBER;
    info->item[3].u.number = port;

    push_object(current_object);
    push_string("acquire", STRING_CONSTANT);
    push_vector(info);

    ret = apply_master_ob("valid_socket", 3);
    if (!IS_ZERO(ret)) {
	i = socket_acquire((sp-3)->u.number, (sp-2)->u.string,
		(sp-1)->u.string, sp->u.string);
	pop_n_elems(4); /* pop both args off stack    */
	push_number(i); /* push return int onto stack */
    } else {
	pop_n_elems(4); /* pop both args off stack    */
	push_number(EESECURITY); /* Security violation attempted */
    }
}

void
f_socket_error(num_arg, instruction)
    int num_arg, instruction;
{
    char *error;

    error = socket_error(sp->u.number);
    pop_stack();    /* pop int arg off stack      */
    push_string(error, STRING_CONSTANT); /* push return string onto stack */
}

void
f_socket_address(num_arg, instruction)
    int num_arg, instruction;
{
    char *str;
    int port;
    char addr[ADDR_BUF_SIZE];
  
    get_socket_address(sp->u.number, addr, &port);
    str = DMALLOC(strlen(addr) + 5 + 3, 2, "f_socket_address");
    sprintf(str, "%s %d", addr, port);
    push_string(str, STRING_MALLOC);
}

void
f_dump_socket_status(num_arg, instruction)
     int num_arg, instruction;
{
  dump_socket_status();
  push_number(0);
}

void
f_sort_array(num_arg, instruction)
int num_arg, instruction;
{
  extern struct vector *sort_array
    PROT((struct vector*,char *,struct object *));
  struct vector *res;
  struct svalue *arg;

  arg = sp - 2; ob = 0;

  if (arg[2].type == T_OBJECT)
    ob = arg[2].u.ob;
  else if (arg[2].type == T_STRING) 
  {
    ob = find_object(arg[2].u.string);
    if (ob && !object_visible(ob)) ob = 0;
  }

  if (!ob)
    bad_arg (3, F_SORT_ARRAY);

  if (arg[0].type == T_POINTER)
    {
      struct vector *tmp;

      tmp = slice_array(arg[0].u.vec, 0, arg[0].u.vec->size-1);
      check_for_destr(tmp);
      res = sort_array(tmp, arg[1].u.string, ob);
    }
    else
      res = 0;
  pop_n_elems (3);
  sp++;
  if (res)
    {
      sp->type = T_POINTER;
      sp->u.vec = res;
    }
  else
    *sp = const0;
}

#ifdef PRINTF
void
f_sprintf(num_arg, instruction)
int num_arg, instruction;
{
  char *s;

  /*
   * string_print_formatted() returns a pointer to it's internal
   * buffer, or to an internal constant...  Either way, it must
   * be copied before it's returned as a string.
   */

  s = string_print_formatted((sp-num_arg+1)->u.string,
			     num_arg-1, sp-num_arg+2);
  pop_n_elems(num_arg);
  if (!s)
    push_number(0);
  else
    push_malloced_string(string_copy(s));
}
#endif

void
f_stat(num_arg, instruction)
int num_arg, instruction;
{
	struct stat buf;
	char *path;
	struct vector *v;
      
	path = (sp-1)->u.string;
	if (*path == '/')
		path++;
	if (stat(path,&buf) != -1) {
		if (buf.st_mode & S_IFREG) { /* if a regular file */
			v = allocate_array(3);
			v->item[0].type = T_NUMBER;
			v->item[0].u.number = buf.st_size;
			v->item[1].type = T_NUMBER;
			v->item[1].u.number = buf.st_mtime;
			v->item[2].type = T_NUMBER;
			ob = find_object2(path);
                if (ob && !object_visible(ob)) ob = 0;
			if (ob)
				v->item[2].u.number = ob->load_time;
			else
				v->item[2].u.number = 0;
			pop_n_elems(2);
			push_vector(v);
			v->ref--;      /* Will now be 1. */
			return;
		}
	}
	v = get_dir((sp-1)->u.string, sp->u.number);
	pop_n_elems(2);
	if (v) {
		push_vector(v);
		v->ref--;			/* Will now be 1. */
	} else {
		push_number(0);
	}
}

void
f_strcmp(num_arg, instruction)
int num_arg, instruction;
{
	i = strcmp((sp - 1)->u.string, sp->u.string);
	pop_n_elems(2);
	push_number(i);
}

void
f_stringp(num_arg, instruction)
int num_arg, instruction;
{
  if (sp->type == T_STRING)
    assign_svalue(sp, &const1);
  else
    assign_svalue(sp, &const0);
}

void
f_strlen(num_arg, instruction)
int num_arg, instruction;
{
	i = strlen(sp->u.string);
	pop_stack();
	push_number(i);
}

void
f_swap(num_arg, instruction)
int num_arg, instruction;
{
  (void)swap(sp->u.ob);
}

void
f_tail(num_arg, instruction)
int num_arg, instruction;
{
  if (tail(sp->u.string))
    assign_svalue(sp, &const1);
  else
    assign_svalue(sp, &const0);
}

void
f_tell_object(num_arg, instruction)
int num_arg, instruction;
{
  tell_object((sp-1)->u.ob, sp->u.string);
  pop_stack();			/* Return first argument */
}

#ifdef F_TELL_ROOM
void
f_tell_room(num_arg, instruction)
int num_arg, instruction;
{
  struct svalue *arg = sp- num_arg + 1;
  struct vector *avoid;

  if (arg[0].type == T_OBJECT)
    ob = arg[0].u.ob;
  else
  {
    ob = find_object(arg[0].u.string);
   if (!ob || !object_visible(ob))
      error("Object not found.\n");
  }
  if (num_arg == 2)
  {
    avoid = null_array();
  }
  else
  {
    extern struct vector *order_alist PROT((struct vector *));
    struct vector *vtmpp;
    static struct vector vtmp = { 1, 1,
#ifdef DEBUG
				    1,
#endif
				    {(mudlib_stats_t *)NULL,
				       (mudlib_stats_t *)NULL},
				    { { T_POINTER } }
				  };

    if (arg[2].type != T_POINTER)
      bad_arg(3, instruction);
    vtmp.item[0].u.vec = arg[2].u.vec;
    if (vtmp.item[0].u.vec->ref > 1)
    {
      vtmp.item[0].u.vec->ref--;
      vtmp.item[0].u.vec = slice_array(vtmp.item[0].u.vec, 0,
				       vtmp.item[0].u.vec->size-1);
    }
    sp--;
    vtmpp = order_alist(&vtmp);
    avoid = vtmpp->item[0].u.vec;
    vtmpp->item[0].u.vec = vtmp.item[0].u.vec;
    free_vector(vtmpp);
  }
  tell_room(ob, sp, avoid);
  free_vector(avoid);
  pop_stack();
}
#endif /* F_TELL_ROOM */

void
f_test_bit(num_arg, instruction)
int num_arg, instruction;
{
  int len;

  len = strlen((sp-1)->u.string);
  if (sp->u.number/6 >= len)
  {
    pop_n_elems(2);
    push_number(0);
    return;
  }
  if (((sp-1)->u.string[sp->u.number/6] - ' ') & (1 << (sp->u.number % 6)))
  {
    pop_n_elems(2);
    push_number(1);
  }
  else
  {
    pop_n_elems(2);
    push_number(0);
  }
}

void
f_this_object(num_arg, instruction)
int num_arg, instruction;
{
  if (current_object->flags & O_DESTRUCTED) /* Fixed from 3.1.1 */
    push_number(0);
  else
    push_object(current_object);
}

void
f_this_player(num_arg, instruction)
int num_arg, instruction;
{
  pop_n_elems(num_arg);
  if (num_arg && current_interactive &&
      !(current_interactive->flags & O_DESTRUCTED))
    push_object(current_interactive);
  else if (command_giver && !(command_giver->flags & O_DESTRUCTED))
    push_object(command_giver);
  else
    push_number(0);
}

void
f_throw(num_arg, instruction)
int num_arg, instruction;
{
	assign_svalue(&catch_value, sp--);
	throw_error();		/* do the longjump, with extra checks... */
}

void
f_time(num_arg, instruction)
int num_arg, instruction;
{
  push_number(current_time);
}

void
f_trace(num_arg, instruction)
int num_arg, instruction;
{
  int ot = -1;
  if (command_giver && command_giver->interactive &&
      command_giver->flags & O_IS_WIZARD) {
    ot = command_giver->interactive->trace_level;
    command_giver->interactive->trace_level = sp->u.number;
  }
  pop_stack();
  push_number(ot);
}

void
f_traceprefix(num_arg, instruction)
int num_arg, instruction;
{
  char *old = 0;

  if (command_giver && command_giver->interactive &&
      command_giver->flags & O_IS_WIZARD)
    {
      old = command_giver->interactive->trace_prefix;
      if (sp->type == T_STRING)
      {
	command_giver->interactive->trace_prefix = 
	  make_shared_string(sp->u.string);
      }
      else
	command_giver->interactive->trace_prefix = 0;
    }
  pop_stack();
  if (old)
  {
    push_string(old, STRING_SHARED); /* Will incr ref count */
    free_string(old);
  }
  else
  {
    push_number(0);
  }
}


void
f_type(num_arg, instruction)
int num_arg, instruction;
{
  int k;

  k = sp->type;
  pop_stack();
  push_number(k);
}

void
f_undefinedp(num_arg, instruction)
int num_arg, instruction;
{
  if (IS_UNDEFINED(sp))
    assign_svalue(sp, &const1);
  else
    assign_svalue(sp, &const0);
}

void
f_unique_array(num_arg, instruction)
int num_arg, instruction;
{
  extern struct vector
    *make_unique PROT((struct vector *arr,char *func,
		       struct svalue *skipnum));
  struct vector *res;

  if (num_arg < 3)
  {
    check_for_destr((sp-1)->u.vec);
    res = make_unique((sp-1)->u.vec, sp->u.string, &const0);
  }
  else
  {
    check_for_destr((sp-2)->u.vec);
    res = make_unique((sp-2)->u.vec, (sp-1)->u.string, sp);
    pop_stack ();
  }
  pop_n_elems(2);
  if (res)
  {
    push_vector (res);		/* This will make ref count == 2 */
    res->ref--;
  }
  else
    push_number (0);
}

void
f_uptime(num_arg, instruction)
int num_arg, instruction;
{
	push_number(current_time - boot_time);
}

void
f_userp(num_arg, instruction)
int num_arg, instruction;
{
  i = (int)sp->u.ob->flags & O_ONCE_INTERACTIVE;
  pop_stack();
  push_number(i != 0);
}

void
f_users(num_arg, instruction)
int num_arg, instruction;
{
  push_vector(users());		/* users() has already set ref count to 1 */
  sp->u.vec->ref--;
}

void
f_version(num_arg, instruction)
int num_arg, instruction;
{
  char buff[80];		/* expanded this a little */
      
  get_version(buff);
  push_string(buff, STRING_MALLOC);
}

void
f_wizardp(num_arg, instruction)
int num_arg, instruction;
{
  i = (int)sp->u.ob->flags & O_IS_WIZARD;
  pop_stack();
  push_number(i != 0);
}


void
f_domain_stats(num_arg, instruction)
int num_arg, instruction;
{
	struct mapping *m;

	if (num_arg) {
		m = get_domain_stats(sp->u.string);
		pop_stack();
	} else {
		m = get_domain_stats(0);
	}
	if (!m) {
		push_number(0);
	} else {
		/* ref count is properly decremented by get_domain_stats */
		push_mapping(m);
	}
}

void
f_author_stats(num_arg, instruction)
int num_arg, instruction;
{
	struct mapping *m;

	if (num_arg) {
		m = get_author_stats(sp->u.string);
		pop_stack();
	} else {
		m = get_author_stats(0);
	}
	if (!m) {
		push_number(0);
	} else {
		/* ref count is properly decremented by get_author_stats */
		push_mapping(m);
	}
}

void
f_set_author (num_arg, instruction)
     int num_arg, instruction;
{
  set_author (sp->u.string);
}

#ifdef F_WRITE
void
f_write(num_arg, instruction)
int num_arg, instruction;
{
  do_write(sp);
}
#endif /* F_WRITE */

void
f_write_bytes(num_arg, instruction)
int num_arg, instruction;
{
	if (IS_ZERO(sp)) {
		bad_arg(3, instruction);
		pop_n_elems(3);
		push_number(0);	
	} else {
		i = write_bytes((sp-2)->u.string, (sp-1)->u.number, sp->u.string);
		pop_n_elems(3);
		push_number(i);
	}
}

void
f_write_file(num_arg, instruction)
int num_arg, instruction;
{
	if (IS_ZERO(sp)) {
		bad_arg(2, instruction);
		pop_n_elems(2);
		push_number(0);	
	} else {
		i = write_file((sp-1)->u.string, sp->u.string);
		pop_n_elems(2);
		push_number(i);	
	}
}

void
f_dump_file_descriptors(num_arg, instruction)
int num_arg, instruction;
{
  dump_file_descriptors();
  push_number(0);	
}

#ifdef F_EVENT
void
f_event(num_args, instruction)
int num_args, instruction;
{
  event((sp-num_args+1), (sp-num_args+2)->u.string, num_args-2,
        (sp-num_args+3));
  pop_n_elems(num_args-1);
}
#endif /* F_EVENT */

#ifdef F_FILE_LENGTH
void
f_file_length(num_arg, instruction)
int num_arg, instruction;
{
  int l;

  l = file_length(sp->u.string);
  pop_stack();
  push_number(l);
}
#endif /* F_FILE_LENGTH */

#ifdef F_PLURALIZE
void
f_pluralize(num_arg, instruction)
int num_arg, instruction;
{
  char *s;
  extern char *pluralize();

  s = pluralize(sp->u.string);
  pop_stack();
  if (!s)
    push_number(0);
  else
    push_malloced_string(s);
}
#endif /* F_PLURALIZE */

#ifdef F_ACTIONS_DEFINED
void f_actions_defined(num_arg, instruction)
int num_arg, instruction;
{
  struct vector *v;
  extern struct vector *actions_defined();
  struct object *arg1, *arg2;
  int arg3;

  if (num_arg && ((sp-num_arg+1)->type == T_OBJECT))
          arg1 = (sp-num_arg+1)->u.ob;
  else arg1 = 0;
  if ((num_arg > 1) && ((sp-num_arg)->type == T_OBJECT))
    arg2 = (sp-num_arg)->u.ob;
  else arg2 = 0;
  if (num_arg > 2) /* only first two arg types caught by parser */
    if (sp->type != T_NUMBER) bad_arg(3, instruction);
    else arg3 = sp->u.number;
  else arg3 = 0; /* defaults to no optional data */
  v = actions_defined(arg1, arg2, arg3);
  pop_n_elems(num_arg);
  push_vector(v);
  v->ref--; /* fix ref count */
}
#endif /* F_ACTIONS_DEFINED */
